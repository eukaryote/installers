#!/bin/sh

# Install Zsh 5.2 or newer, verifying GPG signature, and installing to
# ZSH_BASE/VERSION, where ZSH_BASE defaults to /opt/zsh if not provided.

EXT="${EXT:-$(if which xz > /dev/null 2>&1 ; then echo -n tar.xz; else echo -n tar.gz; fi)}"
ZSH_BASE="${ZSH_BASE:-/opt/zsh}"

# Only Zsh versions 5.2 and newer have GPG signatures on sourceforge.
SIGNED_GPG_VERSIONS="5.2"

url_base='https://downloads.sourceforge.net/zsh/zsh'

err() {
    >&2 echo "$@"
}

precheck() {
    local program
    for program in curl tar gpg
    do
        if ! which "${program}" >/dev/null 2>&1
        then
            err "ERROR: couldn't find required dependency '${program}' on PATH"
            return 1
        fi
    done
}

prepare() {
    local source_package=$1
    local doc_package=$2
    local version=$3
    local build_dir=$4

    [ -n "${source_package}" -a -n "${doc_package}" -a -n "${version}" -a -n "${build_dir}" ] || {
        err "usage: prepare source_package doc_package version build_dir"
        return 1
    }
    [ -d "${build_dir}" ] || {
        err "ERROR: invalid directory: ${build_dir}"
        return 1
    }

    local install_dir="${ZSH_BASE}/${version}"
    mkdir -p "${install_dir}" || {
        local rc=$?
        err "ERROR (${rc}): failed to create install dir: ${install_dir}"
        return "${rc}"
    }

    [ ! -w "${install_dir}}" ] || {
        local rc=$?
        err "ERROR (${rc}): install dir exists but is not writable: ${install_dir}"
        return "${rc}"
    }

    cd "${build_dir}" >/dev/null || return $?
    local url
    for file in "${source_package}" "${source_package}.asc" "${doc_package}" "${doc_package}.asc"
    do
        url="${url_base}/${version}/${file}"
        echo " - downloading: ${url}"
        curl -s --fail -L -g -o "${file}" "${url}" || {
            local rc=$?
            err "ERROR (${rc}): couldn't download file from URL '${url}'"
            return "${rc}"
        }
    done

    echo " - verifying ${source_package}.asc ${source_package}"
    gpg --verify "${source_package}.asc" "${source_package}" > /dev/null 2>&1 || {
        local rc=$?
        echo
        err "ERROR (${rc}): couldn't verify source package '${source_package}' signature '${source_package}.asc'"
        return "${rc}"
    }

    echo " - verifying ${doc_package}.asc ${doc_package}"
    gpg --verify "${doc_package}.asc" "${doc_package}" > /dev/null 2>&1 || {
        local rc=$?
        err "ERROR (${rc}): couldn't verify doc package '${doc_package}' signature '${doc_package}.asc'"
        return "${rc}"
    }
    echo " - unpacking ${source_package}"
    tar xf "${source_package}" || return $?

    echo " - unpacking ${doc_package}"
    tar xf "${doc_package}"
}

make_build_dir() {
    local version=$1
    [ -n "${version}" ] || {
        err "usage: make_build_dir VERSION"
        return 1
    }

    local build_dir
    build_dir=$(umask 077 && mktemp -d -t install_zsh_"$(echo -n "${version}" | tr . _)"_XXXXXX) || {
        local rc=$?
        err "Error ${mktemp_status} creating build dir using mktemp -d"
        err "Check \$TMPDIR and verify that it is set to a suitable directory"
        return "${rc}"
    }
    echo -n "${build_dir}"
}


run_all() {
    precheck || return $?
    local version=$1
    [ -n "${version}" ] || {
        err "usage: install_zsh VERSION"
        return 1
    }

    if [ "$(awk "BEGIN{ print \"${version}\"<\"5.2\" }" < /dev/null)" -eq 1 ]
    then
        >&2 echo "ERROR: only installation of 5.2 and newer is supported"
        return 1
    fi

    local install_dir="${ZSH_BASE}/${version}"
    if [ -f "${install_dir}/bin/zsh" ]
    then
        echo "zsh version already exists: ${install_dir}/bin/zsh"
        return 1
    fi

    local build_dir
    build_dir="$(make_build_dir "${version}")" || return $?

    trap "rc=\$?; set -u; command rm -rf \"${build_dir}\"; exit $rc" 0

    echo " - using build dir: ${build_dir}"
    echo " - using install dir: ${install_dir}"

    local source_package="zsh-${version}.${EXT}"
    local doc_package="zsh-${version}-doc.${EXT}"

    cd "${build_dir}" >/dev/null || {
        local rc=$?
        err "ERROR (${rc}): couldn't cd to build directory '${build_dir}'"
        return "${rc}"
    }

    prepare "${source_package}" "${doc_package}" "${version}" "${build_dir}" || return $?
    cd "$(basename "${source_package}" ".${EXT}")" >/dev/null || return $?

    echo -n " - configuring"
     ./configure --prefix="${install_dir}" > "${build_dir}/configure.log" 2>&1 || {
        local rc=$?
        err "ERROR (${rc}): configure failed"
        return "${rc}"
     }
     echo

     echo -n " - compiling"
     make > "${build_dir}/compile.log" 2>&1 || {
        local rc=$?
        err "ERROR (${rc}): make failed"
        return "${rc}"
     }
     echo

     echo -n " - installing"
     make install > "${build_dir}/install.log" 2>&1 || {
        local rc=$?
        err "ERROR (${rc}): make install failed"
        return "${rc}"
     }
     echo

     mkdir "${install_dir}/.build" || {
        local rc=$?
        err "ERROR (${rc}): couldn't create ${install_dir}/.build to store logs"
        return "${rc}"
     }

    echo " - storing logs in ${install_dir}/.build"
    if test -n "$(find "${build_dir}" -maxdepth 1 -name '*.log' -print -quit)"
    then
        cp -p -u "${build_dir}"/*.log "${install_dir}"/.build/ || return $?
    fi

    return 0
 }


run_all "$@"
